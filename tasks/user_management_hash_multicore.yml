---
# Description: Generate password hash for Multi-Core mode users
# Version: 2.0.0 - FIXED: Binary concatenation like auth_management.yml
# This file is included by user_management.yml for each core user
# Receives: core_user_item (tuple of core config and user config)
# Changelog v2.0.0:
#   - CRITICAL FIX: Changed to binary concatenation (like auth_management.yml)
#   - REASON: Text concatenation produces DIFFERENT hashes than binary!
#   - IMPACT: Multicore user passwords now work correctly

- name: user-hash-mc - Extract user config
  set_fact:
    mc_core_name: "{{ core_user_item.0.name }}"
    mc_user: "{{ core_user_item.1 }}"
  no_log: true

- name: user-hash-mc - Check if password was generated for this user
  set_fact:
    mc_generated_cred: "{{ generated_credentials | selectattr('core', 'equalto', mc_core_name) | selectattr('username', 'equalto', mc_user.username) | list | first | default(None) }}"
  no_log: true

- name: user-hash-mc - Use generated password if available
  set_fact:
    mc_user: "{{ mc_user | combine({'password': mc_generated_cred.password}) }}"
  no_log: true
  when: mc_generated_cred is not none and mc_generated_cred.was_generated | default(false)

- name: user-hash-mc - Create temp directory for hashing
  file:
    path: /tmp/solr_mc_hash_{{ ansible_date_time.epoch }}_{{ mc_user.username | regex_replace('[^a-zA-Z0-9]', '_') }}
    state: directory
    mode: '0700'
  register: mc_hash_temp_dir

- name: user-hash-mc - Generate hash for {{ mc_user.username }} with binary concatenation
  shell: |
    set -e

    # Detect base64 command
    if base64 --help 2>&1 | grep -q 'wrap'; then
      BASE64_CMD="base64 -w0"
    else
      BASE64_CMD="base64"
    fi

    # Generate random salt (32 bytes for SHA256)
    openssl rand {{ solr_hash_salt_bytes | default(32) }} > {{ mc_hash_temp_dir.path }}/salt.bin

    # Write password from environment variable (safe from injection)
    printf '%s' "$USER_PASSWORD" > {{ mc_hash_temp_dir.path }}/pass.bin

    # Binary concatenation (SAME as auth_management.yml!)
    cat {{ mc_hash_temp_dir.path }}/salt.bin {{ mc_hash_temp_dir.path }}/pass.bin > {{ mc_hash_temp_dir.path }}/combined.bin

    # Double SHA256
    openssl dgst -sha256 -binary {{ mc_hash_temp_dir.path }}/combined.bin > {{ mc_hash_temp_dir.path }}/hash1.bin
    openssl dgst -sha256 -binary {{ mc_hash_temp_dir.path }}/hash1.bin > {{ mc_hash_temp_dir.path }}/hash2.bin

    # Base64 encode
    HASH_B64=$(${BASE64_CMD} < {{ mc_hash_temp_dir.path }}/hash2.bin | tr -d '\n\r')
    SALT_B64=$(${BASE64_CMD} < {{ mc_hash_temp_dir.path }}/salt.bin | tr -d '\n\r')

    # Output format: "HASH SALT"
    echo "${HASH_B64} ${SALT_B64}"
  args:
    executable: /bin/bash
  environment:
    USER_PASSWORD: "{{ mc_user.password }}"
  register: mc_hash_output
  changed_when: false
  no_log: true

- name: user-hash-mc - Cleanup temp directory
  file:
    path: "{{ mc_hash_temp_dir.path }}"
    state: absent
  when:
    - mc_hash_temp_dir is defined
    - mc_hash_temp_dir.path is defined
  failed_when: false

- name: user-hash-mc - Store hash
  set_fact:
    mc_combined_hash: "{{ mc_hash_output.stdout }}"
  no_log: true

- name: user-hash-mc - Determine roles for {{ mc_user.username }} (custom roles)
  set_fact:
    mc_user_roles: "{{ mc_user.roles }}"
  when: mc_user.roles is defined

- name: user-hash-mc - Determine roles for {{ mc_user.username }} (admin convention)
  set_fact:
    mc_user_roles: ["admin"]
  when:
    - mc_user.roles is not defined
    - mc_user.username is match('.*_admin$')

- name: user-hash-mc - Determine roles for {{ mc_user.username }} (moodle convention)
  set_fact:
    mc_user_roles: ["moodle"]
  when:
    - mc_user.roles is not defined
    - mc_user.username is match('.*_moodle$')

- name: user-hash-mc - Determine roles for {{ mc_user.username }} (readonly convention)
  set_fact:
    mc_user_roles: ["support"]
  when:
    - mc_user.roles is not defined
    - mc_user.username is match('.*_readonly$')

- name: user-hash-mc - Determine roles for {{ mc_user.username }} (default fallback)
  set_fact:
    mc_user_roles: ["moodle"]
  when:
    - mc_user.roles is not defined
    - not (mc_user.username is match('.*_admin$'))
    - not (mc_user.username is match('.*_moodle$'))
    - not (mc_user.username is match('.*_readonly$'))

- name: user-hash-mc - Add user hash to dictionary
  set_fact:
    solr_additional_user_hashes: "{{ solr_additional_user_hashes | combine({mc_user.username: mc_combined_hash}) }}"
  no_log: true

- name: user-hash-mc - Add user roles to dictionary
  set_fact:
    solr_additional_user_roles: "{{ solr_additional_user_roles | combine({mc_user.username: mc_user_roles}) }}"

---
# Version: 1.3.2 - FIXED: Inline platform detection 
# Description: Pre-hash passwords for Solr authentication (SOLR-COMPATIBLE SHA256)

- name: install-solr - Check for existing security.json
  stat:
    path: "{{ solr_config_dir }}/security.json"
  register: existing_security_json

- name: install-solr - Skip if auth already configured
  block:
    - name: install-solr - Display skip message
      debug:
        msg:
          - "AUTH ALREADY CONFIGURED"
          - "File: {{ solr_config_dir }}/security.json exists"
          - "To reconfigure: set solr_force_reconfigure_auth: true"
    
    - name: install-solr - End play for this host
      meta: end_host
  when:
    - existing_security_json.stat.exists
    - not solr_force_reconfigure_auth | default(false)

- name: install-solr - Create temp directory for binary operations
  file:
    path: /tmp/solr_hash_{{ ansible_date_time.epoch }}
    state: directory
    mode: '0700'
  register: temp_dir

- name: install-solr - Set temp directory fact
  set_fact:
    hash_temp_dir: "{{ temp_dir.path }}"

- name: install-solr - Resolve or generate admin password
  set_fact:
    admin_password: "{{ solr_admin_password | default(lookup('password', '/dev/null chars=ascii_letters,digits length=20')) }}"
  no_log: true

- name: install-solr - Resolve or generate support password
  set_fact:
    support_password: "{{ solr_support_password | default(lookup('password', '/dev/null chars=ascii_letters,digits length=16')) }}"
  no_log: true

- name: install-solr - Resolve or generate customer password
  set_fact:
    customer_password: "{{ solr_customer_password | default(lookup('password', '/dev/null chars=ascii_letters,digits length=16')) }}"
  no_log: true

- name: install-solr - Generate SHA256 hash for admin (CROSS-PLATFORM) 
  shell: 
    cmd: | 
      set -e 
      
      # Detect base64 command inline 
      if base64 --help 2>&1 | grep -q 'wrap'; then 
        BASE64_CMD="base64 -w0" 
      else 
        BASE64_CMD="base64" 
      fi 
      
      # Generate 32 random bytes for salt
      openssl rand 32 > {{ hash_temp_dir }}/admin_salt.bin
      
      # Write password as binary
      printf '%s' "{{ admin_password }}" > {{ hash_temp_dir }}/admin_pass.bin
      
      # Binary concatenation: salt + password
      cat {{ hash_temp_dir }}/admin_salt.bin {{ hash_temp_dir }}/admin_pass.bin > {{ hash_temp_dir }}/admin_combined.bin
      
      # Double SHA256 on binary data
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/admin_combined.bin > {{ hash_temp_dir }}/admin_hash1.bin
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/admin_hash1.bin > {{ hash_temp_dir }}/admin_hash2.bin
      
      # Base64 encode both hash and salt (platform independent) 
      HASH_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/admin_hash2.bin | tr -d '\n\r') 
      SALT_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/admin_salt.bin | tr -d '\n\r') 
      
      # Output format: "HASH SALT" (space-separated)
      echo "${HASH_B64} ${SALT_B64}"
    executable: /bin/bash 
  register: admin_hash
  changed_when: false
  no_log: true

- name: install-solr - Generate SHA256 hash for support (CROSS-PLATFORM) 
  shell: 
    cmd: | 
      set -e 
      
      # Detect base64 command inline 
      if base64 --help 2>&1 | grep -q 'wrap'; then 
        BASE64_CMD="base64 -w0" 
      else 
        BASE64_CMD="base64" 
      fi 
      
      openssl rand 32 > {{ hash_temp_dir }}/support_salt.bin
      printf '%s' "{{ support_password }}" > {{ hash_temp_dir }}/support_pass.bin
      cat {{ hash_temp_dir }}/support_salt.bin {{ hash_temp_dir }}/support_pass.bin > {{ hash_temp_dir }}/support_combined.bin
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/support_combined.bin > {{ hash_temp_dir }}/support_hash1.bin
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/support_hash1.bin > {{ hash_temp_dir }}/support_hash2.bin
      HASH_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/support_hash2.bin | tr -d '\n\r') 
      SALT_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/support_salt.bin | tr -d '\n\r') 
      echo "${HASH_B64} ${SALT_B64}"
    executable: /bin/bash 
  register: support_hash
  changed_when: false
  no_log: true

- name: install-solr - Generate SHA256 hash for customer (CROSS-PLATFORM) 
  shell: 
    cmd: | 
      set -e 
      
      # Detect base64 command inline 
      if base64 --help 2>&1 | grep -q 'wrap'; then 
        BASE64_CMD="base64 -w0" 
      else 
        BASE64_CMD="base64" 
      fi 
      
      openssl rand 32 > {{ hash_temp_dir }}/customer_salt.bin
      printf '%s' "{{ customer_password }}" > {{ hash_temp_dir }}/customer_pass.bin
      cat {{ hash_temp_dir }}/customer_salt.bin {{ hash_temp_dir }}/customer_pass.bin > {{ hash_temp_dir }}/customer_combined.bin
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/customer_combined.bin > {{ hash_temp_dir }}/customer_hash1.bin
      openssl dgst -sha256 -binary {{ hash_temp_dir }}/customer_hash1.bin > {{ hash_temp_dir }}/customer_hash2.bin
      HASH_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/customer_hash2.bin | tr -d '\n\r') 
      SALT_B64=$(${BASE64_CMD} < {{ hash_temp_dir }}/customer_salt.bin | tr -d '\n\r') 
      echo "${HASH_B64} ${SALT_B64}"
    executable: /bin/bash 
  register: customer_hash
  changed_when: false
  no_log: true

- name: install-solr - Set hash facts
  set_fact:
    admin_password_hash: "{{ admin_hash.stdout }}"
    support_password_hash: "{{ support_hash.stdout }}"
    customer_password_hash: "{{ customer_hash.stdout }}"
  no_log: true

- name: install-solr - Validate SHA256 hash format
  assert:
    that:
      - admin_password_hash is match('^[A-Za-z0-9+/=]+ [A-Za-z0-9+/=]+$')
      - support_password_hash is match('^[A-Za-z0-9+/=]+ [A-Za-z0-9+/=]+$')
      - customer_password_hash is match('^[A-Za-z0-9+/=]+ [A-Za-z0-9+/=]+$')
      - admin_password_hash.split(' ') | length == 2
      - support_password_hash.split(' ') | length == 2
      - customer_password_hash.split(' ') | length == 2
    fail_msg: "SHA256 hash validation failed - incorrect format (expected: 'HASH SALT')"
    success_msg: "All SHA256 hashes validated successfully"

- name: install-solr - Cleanup temp directory
  file:
    path: "{{ hash_temp_dir }}"
    state: absent

- name: install-solr - Display hash format info
  debug:
    msg:
      - "HASH FORMAT: Solr-compatible SHA256 double-hash with BINARY concatenation"
      - "Algorithm: base64(sha256(sha256(salt_bytes+password_bytes))) base64(salt_bytes)"
      - "Method: Binary concatenation via temp files with inline platform detection" 
      - "Admin hash length: {{ admin_password_hash | length }} chars"
      - "Support hash length: {{ support_password_hash | length }} chars"
      - "Customer hash length: {{ customer_password_hash | length }} chars"
      - "Format: HASH SALT (space-separated)"

- name: install-solr - Create Rundeck output
  set_fact:
    auth_prehash_result:
      status: "success"
      timestamp: "{{ ansible_date_time.iso8601 }}"
      message: "Password hashing completed"
      details:
        method: "sha256_double_hash_binary"
        format: "base64(sha256(sha256(salt_bytes+password_bytes))) base64(salt_bytes)"
        tool: "openssl with binary concatenation"
        platform_detection: "inline" 
        salt_size_bytes: 32
        users:
          - "{{ solr_admin_user }}"
          - "{{ solr_support_user }}"
          - "{{ solr_customer_user }}"
        solr_compatible: true
        version: "1.3.2" 
  when: rundeck_integration_enabled | default(false)

- name: install-solr - Display prehash summary
  debug:
    msg: "{{ auth_prehash_result | to_nice_json }}"
  when: rundeck_integration_enabled | default(false)

- name: install-solr - Display standard summary
  debug:
    msg:
      - "SHA256 DOUBLE-HASH PASSWORD HASHING COMPLETED (BINARY METHOD)"
      - "Algorithm: base64(sha256(sha256(salt_bytes+password_bytes))) base64(salt_bytes)"
      - "Tool: OpenSSL with binary file concatenation"
      - "Platform: Auto-detected inline per command" 
      - "Salt size: 32 bytes per user"
      - "Format: HASH SALT (space-separated base64)"
      - "Validation: PASSED"
      - ""
  when: not rundeck_integration_enabled | default(false)
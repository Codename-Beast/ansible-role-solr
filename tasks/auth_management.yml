---
# Version: 1.4.0
# Description: Unified auth detection and password hashing with loops
# Consolidates: auth_detection.yml + auth_prehash.yml
# Changelog v1.4.0:
#   - FIX CRITICAL: Prevent password regeneration when passwords already exist
#   - ADDED: Validation to ensure password variables match hashed passwords
#   - ADDED: Debug output showing password source (host_vars vs generated)
#   - ADDED: Pre-hash validation to ensure all passwords >= 12 chars
#   - ADDED: Post-hash validation to prevent variable mismatch errors
#   - FIXED: Removed duplicate password variable assignments
#   - This fixes "401 Bad credentials" errors during core creation
# Changelog v1.3.2:
#   - FIXED: HOME environment variable validation
#   - FIXED: Shell injection prevention with environment variables
#   - FIXED: Temp directory guaranteed cleanup
# Changelog v1.3.1:
#   - FIXED: Full idempotency support for unlimited re-runs
#   - OPTIMIZED: Loop-based processing for all users

# ============================================================================
#  ENVIRONMENT VALIDATION
# ============================================================================

- name: auth-mgmt - Security validation - Prevent path traversal via inventory_hostname
  assert:
    that:
      - "'../' not in inventory_hostname"
      - "'..' not in inventory_hostname"
      - "'/' not in inventory_hostname"
      - inventory_hostname is match('^[a-zA-Z0-9._-]+$')
    fail_msg: |
      SECURITY ERROR: inventory_hostname contains invalid characters.
      inventory_hostname: {{ inventory_hostname }}
      Only alphanumeric characters, dots, underscores, and hyphens are allowed.
      This prevents path traversal attacks.
    success_msg: "inventory_hostname validated: {{ inventory_hostname }}"
  tags: [always]

# ============================================================================
#  DETECTION - Check if existing hashes match passwords
# ============================================================================

- name: auth-mgmt - Check if security.json exists
  stat:
    path: "{{ solr_config_dir }}/security.json"
  register: existing_security_json

- name: auth-mgmt - Initialize auth variables
  set_fact:
    skip_auth: false
    auth_users:
      - name: admin
        username: "{{ solr_admin_user | default('admin') }}"
        password: "{{ solr_admin_password | default('') }}"
      - name: support
        username: "{{ solr_support_user | default('support') }}"
        password: "{{ solr_support_password | default('') }}"
      - name: moodle
        username: "{{ solr_moodle_user | default('moodle') }}"
        password: "{{ solr_moodle_password | default('') }}"

- name: auth-mgmt - Read existing security.json
  slurp:
    src: "{{ solr_config_dir }}/security.json"
  register: security_json_content
  become: true
  when: existing_security_json.stat.exists

- name: auth-mgmt - Parse existing security.json
  set_fact:
    security_json_parsed: "{{ security_json_content.content | b64decode | from_json }}"
  when:
    - existing_security_json.stat.exists
    - security_json_content is defined
    - security_json_content.content is defined

- name: auth-mgmt - Password verification with guaranteed cleanup
  block:
    - name: auth-mgmt - Create temp directory for verification
      file:
        path: /tmp/solr_verify_{{ ansible_date_time.epoch }}
        state: directory
        mode: '0700'
      register: verify_temp_dir

    - name: auth-mgmt - Verify password hashes for all users
      shell: |
        set -e

        # Detect base64 command
        if base64 --help 2>&1 | grep -q 'wrap'; then
          BASE64_CMD="base64 -w0"
        else
          BASE64_CMD="base64"
        fi

        # Use environment variables to avoid shell injection
        if [ -z "$EXISTING_HASH" ] || [ -z "$USER_PASSWORD" ]; then
          echo "mismatch"
          exit 0
        fi

        # Extract salt from existing hash
        SALT_B64=$(echo "$EXISTING_HASH" | awk '{print $2}')

        # Decode salt
        echo "$SALT_B64" | base64 -d > {{ verify_temp_dir.path }}/{{ item.name }}_salt.bin

        # Write password from environment variable (safe from injection)
        printf '%s' "$USER_PASSWORD" > {{ verify_temp_dir.path }}/{{ item.name }}_pass.bin

        # Binary concatenation
        cat {{ verify_temp_dir.path }}/{{ item.name }}_salt.bin {{ verify_temp_dir.path }}/{{ item.name }}_pass.bin > {{ verify_temp_dir.path }}/{{ item.name }}_combined.bin

        # Double SHA256
        openssl dgst -sha256 -binary {{ verify_temp_dir.path }}/{{ item.name }}_combined.bin > {{ verify_temp_dir.path }}/{{ item.name }}_hash1.bin
        openssl dgst -sha256 -binary {{ verify_temp_dir.path }}/{{ item.name }}_hash1.bin > {{ verify_temp_dir.path }}/{{ item.name }}_hash2.bin

        # Base64 encode
        HASH_B64=$(${BASE64_CMD} < {{ verify_temp_dir.path }}/{{ item.name }}_hash2.bin | tr -d '\n\r')

        # Compare
        EXPECTED_HASH="${HASH_B64} ${SALT_B64}"
        if [ "$EXPECTED_HASH" = "$EXISTING_HASH" ]; then
          echo "match"
        else
          echo "mismatch"
        fi
      args:
        executable: /bin/bash
      environment:
        USER_PASSWORD: "{{ item.password }}"
        EXISTING_HASH: "{{ security_json_parsed.authentication.credentials[item.username] | default('') }}"
      loop: "{{ auth_users }}"
      loop_control:
        label: "{{ item.name }}"
      register: hash_verification
      changed_when: false
      no_log: true

  always:
    - name: auth-mgmt - Cleanup verification temp directory
      file:
        path: "{{ verify_temp_dir.path }}"
        state: absent
      when:
        - verify_temp_dir is defined
        - verify_temp_dir.path is defined
      failed_when: false

  when:
    - existing_security_json.stat.exists
    - security_json_parsed is defined

- name: auth-mgmt - Determine skip_auth flag
  set_fact:
    skip_auth: "{{ not (solr_force_reconfigure_auth | default(false)) and existing_security_json.stat.exists and hash_verification is defined and (hash_verification.results | selectattr('stdout', 'equalto', 'mismatch') | list | length == 0) }}"

- name: auth-mgmt - Display detection result
  debug:
    msg:
      - "AUTH DETECTION COMPLETED"
      - "security.json exists: {{ existing_security_json.stat.exists }}"
      - "All hashes match: {{ skip_auth }}"
      - "Skip auth regeneration: {{ skip_auth }}"

# ============================================================================
# HASH EXTRACTION - Extract existing hashes when skip_auth=true
# ============================================================================
# When hashes match (skip_auth=true), we still need to set the hash variables
# because security.json template requires them. Without this, template rendering fails.

- name: auth-mgmt - Extract existing password hashes from security.json
  set_fact:
    admin_password_hash: "{{ security_json_parsed.authentication.credentials[solr_admin_user | default('admin')] }}"
    support_password_hash: "{{ security_json_parsed.authentication.credentials[solr_support_user | default('support')] }}"
    moodle_password_hash: "{{ security_json_parsed.authentication.credentials[solr_moodle_user | default('moodle')] }}"
  when:
    - skip_auth
    - existing_security_json.stat.exists
    - security_json_parsed is defined

# ============================================================================
#  PASSWORD AUTO-GENERATION - Generate secure passwords if missing/weak
# ============================================================================

- name: auth-mgmt - Initialize generated credentials tracker
  set_fact:
    generated_credentials: []
    generate_admin_password: false
    generate_support_password: false
    generate_moodle_password: false

# ============================================================================
# CRITICAL: Only generate passwords if they're truly missing or weak
# This prevents runtime errors where new hashes are generated for different passwords
# ============================================================================

- name: auth-mgmt - Check admin password strength
  set_fact:
    generate_admin_password: "{{ (solr_admin_password | default('') | length) < 12 }}"

- name: auth-mgmt - Display admin password status
  debug:
    msg: >-
      Admin password: {{ 'MISSING/WEAK (will generate)' if generate_admin_password | bool else 'OK (using host_vars)' }}
      (length: {{ solr_admin_password | default('') | length }} chars)
  when: not skip_auth

- name: auth-mgmt - Generate admin password if needed
  shell: openssl rand -base64 24 | tr -d '/+=' | head -c 24
  register: generated_admin_pwd
  changed_when: false
  no_log: true
  when: generate_admin_password | bool and not skip_auth

- name: auth-mgmt - Set admin password (generated or provided)
  set_fact:
    solr_admin_password: "{{ generated_admin_pwd.stdout if (generate_admin_password | bool and not skip_auth) else solr_admin_password }}"
  no_log: true
  when: not skip_auth

- name: auth-mgmt - Check support password strength
  set_fact:
    generate_support_password: "{{ (solr_support_password | default('') | length) < 12 }}"

- name: auth-mgmt - Display support password status
  debug:
    msg: >-
      Support password: {{ 'MISSING/WEAK (will generate)' if generate_support_password | bool else 'OK (using host_vars)' }}
      (length: {{ solr_support_password | default('') | length }} chars)
  when: not skip_auth

- name: auth-mgmt - Generate support password if needed
  shell: openssl rand -base64 24 | tr -d '/+=' | head -c 24
  register: generated_support_pwd
  changed_when: false
  no_log: true
  when: generate_support_password | bool and not skip_auth

- name: auth-mgmt - Set support password (generated or provided)
  set_fact:
    solr_support_password: "{{ generated_support_pwd.stdout if (generate_support_password | bool and not skip_auth) else solr_support_password }}"
  no_log: true
  when: not skip_auth

- name: auth-mgmt - Check moodle password strength
  set_fact:
    generate_moodle_password: "{{ (solr_moodle_password | default('') | length) < 12 }}"

- name: auth-mgmt - Display moodle password status
  debug:
    msg: >-
      Moodle password: {{ 'MISSING/WEAK (will generate)' if generate_moodle_password | bool else 'OK (using host_vars)' }}
      (length: {{ solr_moodle_password | default('') | length }} chars)
  when: not skip_auth

- name: auth-mgmt - Generate moodle password if needed
  shell: openssl rand -base64 24 | tr -d '/+=' | head -c 24
  register: generated_moodle_pwd
  changed_when: false
  no_log: true
  when: generate_moodle_password | bool and not skip_auth

- name: auth-mgmt - Set moodle password (generated or provided)
  set_fact:
    solr_moodle_password: "{{ generated_moodle_pwd.stdout if (generate_moodle_password | bool and not skip_auth) else solr_moodle_password }}"
  no_log: true
  when: not skip_auth

# ============================================================================
#  HASHING - Generate new hashes if needed
# ============================================================================

# REMOVED: meta: end_host was stopping the entire playbook
# Now relies on 'when: not skip_auth' conditionals for subsequent tasks

- name: auth-mgmt - Password hashing with guaranteed cleanup
  block:
    - name: auth-mgmt - Create temp directory for hashing
      file:
        path: /tmp/solr_hash_{{ ansible_date_time.epoch }}
        state: directory
        mode: '0700'
      register: hash_temp_dir

    - name: auth-mgmt - Check if passwords are defined
      debug:
        msg: "WARNING: Password for {{ item.name }} not defined, generating random password"
      when: item.password is not defined or item.password | length == 0
      loop:
        - { name: "admin", password: "{{ solr_admin_password | default('') }}" }
        - { name: "support", password: "{{ solr_support_password | default('') }}" }
        - { name: "moodle", password: "{{ solr_moodle_password | default('') }}" }
      loop_control:
        label: "{{ item.name }}"

- name: auth-mgmt - Display password source status
  debug:
    msg:
      - "Password sources:"
      - "  Admin: {{ 'GENERATED (weak/missing)' if generate_admin_password | bool else 'host_vars' }}"
      - "  Support: {{ 'GENERATED (weak/missing)' if generate_support_password | bool else 'host_vars' }}"
      - "  Moodle: {{ 'GENERATED (weak/missing)' if generate_moodle_password | bool else 'host_vars' }}"
  when: not skip_auth

- name: auth-mgmt - Validate all passwords are now available (after generation)
  assert:
    that:
      - solr_admin_password is defined and solr_admin_password | length >= 12
      - solr_support_password is defined and solr_support_password | length >= 12
      - solr_moodle_password is defined and solr_moodle_password | length >= 12
    fail_msg: |
      CRITICAL: Password generation failed!
      This should not happen - please check password generation tasks.
    success_msg: "All passwords ready (from host_vars or auto-generated)"
  when: not skip_auth

- name: auth-mgmt - Validate all passwords before hashing
  assert:
    that:
      - solr_admin_password is defined
      - solr_admin_password | length >= 12
      - solr_support_password is defined
      - solr_support_password | length >= 12
      - solr_moodle_password is defined
      - solr_moodle_password | length >= 12
    fail_msg: |
      CRITICAL: Password validation failed before hashing!
      Admin: {{ 'OK' if solr_admin_password is defined and solr_admin_password | length >= 12 else 'INVALID (length: ' ~ (solr_admin_password | default('') | length) ~ ')' }}
      Support: {{ 'OK' if solr_support_password is defined and solr_support_password | length >= 12 else 'INVALID (length: ' ~ (solr_support_password | default('') | length) ~ ')' }}
      Moodle: {{ 'OK' if solr_moodle_password is defined and solr_moodle_password | length >= 12 else 'INVALID (length: ' ~ (solr_moodle_password | default('') | length) ~ ')' }}
    success_msg: "All passwords validated (>= 12 chars) - ready for hashing"
  when: not skip_auth

- name: auth-mgmt - Build auth_users_with_passwords list
  set_fact:
    auth_users_with_passwords:
      - name: admin
        username: "{{ solr_admin_user | default('admin') }}"
        password: "{{ solr_admin_password }}"
      - name: support
        username: "{{ solr_support_user | default('support') }}"
        password: "{{ solr_support_password }}"
      - name: moodle
        username: "{{ solr_moodle_user | default('moodle') }}"
        password: "{{ solr_moodle_password }}"
  no_log: true
  when: not skip_auth

- name: auth-mgmt - Generate SHA256 hashes for all users
  shell: |
    set -e

    # Detect base64 command
    if base64 --help 2>&1 | grep -q 'wrap'; then
      BASE64_CMD="base64 -w0"
    else
      BASE64_CMD="base64"
    fi

    # Generate random salt
    openssl rand {{ solr_hash_salt_bytes }} > {{ hash_temp_dir.path }}/{{ item.name }}_salt.bin

    # Write password from environment variable (safe from injection)
    printf '%s' "$USER_PASSWORD" > {{ hash_temp_dir.path }}/{{ item.name }}_pass.bin

    # Binary concatenation
    cat {{ hash_temp_dir.path }}/{{ item.name }}_salt.bin {{ hash_temp_dir.path }}/{{ item.name }}_pass.bin > {{ hash_temp_dir.path }}/{{ item.name }}_combined.bin

    # Double SHA256
    openssl dgst -sha256 -binary {{ hash_temp_dir.path }}/{{ item.name }}_combined.bin > {{ hash_temp_dir.path }}/{{ item.name }}_hash1.bin
    openssl dgst -sha256 -binary {{ hash_temp_dir.path }}/{{ item.name }}_hash1.bin > {{ hash_temp_dir.path }}/{{ item.name }}_hash2.bin

    # Base64 encode
    SALT_B64=$(${BASE64_CMD} < {{ hash_temp_dir.path }}/{{ item.name }}_salt.bin | tr -d '\n\r')
    HASH_B64=$(${BASE64_CMD} < {{ hash_temp_dir.path }}/{{ item.name }}_hash2.bin | tr -d '\n\r')

    # Output format: "SALT HASH" (Solr BasicAuth format)
    echo "${SALT_B64} ${HASH_B64}"
  args:
    executable: /bin/bash
  environment:
    USER_PASSWORD: "{{ item.password }}"
  loop: "{{ auth_users_with_passwords }}"
  loop_control:
    label: "{{ item.name }}"
  register: generated_hashes
  changed_when: false
  no_log: true
  when: not skip_auth

- name: auth-mgmt - Set hash facts (passwords already set earlier)
  set_fact:
    admin_password_hash: "{{ generated_hashes.results[0].stdout }}"
    support_password_hash: "{{ generated_hashes.results[1].stdout }}"
    moodle_password_hash: "{{ generated_hashes.results[2].stdout }}"
  no_log: true
  when: not skip_auth

- name: auth-mgmt - Final validation - ensure password variables match hashed passwords
  assert:
    that:
      - solr_admin_password == auth_users_with_passwords[0].password
      - solr_support_password == auth_users_with_passwords[1].password
      - solr_moodle_password == auth_users_with_passwords[2].password
    fail_msg: |
      CRITICAL: Password variable mismatch detected!
      This indicates a bug where password variables don't match what was hashed.
      Admin match: {{ solr_admin_password == auth_users_with_passwords[0].password }}
      Support match: {{ solr_support_password == auth_users_with_passwords[1].password }}
      Moodle match: {{ solr_moodle_password == auth_users_with_passwords[2].password }}
    success_msg: "Password variables match hashed passwords - authentication will work"
  when: not skip_auth

- name: auth-mgmt - Validate hash format
  assert:
    that:
      - item.stdout is match('^[A-Za-z0-9+/=]+ [A-Za-z0-9+/=]+$')
      - item.stdout.split(' ') | length == 2
    fail_msg: "Hash validation failed for {{ item.item.name }}"
  loop: "{{ generated_hashes.results }}"
  loop_control:
    label: "{{ item.item.name }}"
  when: not skip_auth

- name: auth-mgmt - Cleanup hashing temp directory
  file:
    path: "{{ hash_temp_dir.path }}"
    state: absent
  when:
    - not skip_auth
    - hash_temp_dir is defined
    - hash_temp_dir.path is defined
  failed_when: false

- name: auth-mgmt - Display hash summary
  debug:
    msg:
      - "PASSWORD HASHING COMPLETED"
      - "Method: SHA256 double-hash with binary concatenation"
      - "Users processed: {{ auth_users | length }}"
      - "Algorithm: base64(sha256(sha256(salt_bytes+password_bytes))) base64(salt_bytes)"
      - "Salt size: {{ solr_hash_salt_bytes }} bytes"
  when: not skip_auth
